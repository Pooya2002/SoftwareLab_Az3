# SoftwareLab_Az3


## SOLID دستور آزمایش

### گام ۱: افزودن یک روش پیام رسانی دیگر

1.	بدون آن که متدی را از واسط Messaging Service حذف کنید ، یک سرویس دیگری را به منظور ارسال پیام از تلگرام با داشتن آیدی مبدا و آیدی مقصد ایجاد کنید - به تبع آن لازم است که یک زیر کلاس برای Message به نام Telegeram Message اضافه کنید که در آن سرویس مورد استفاده قرار گیرد.
2.	سپس یک تابع برای ارسال پیام تلگرامی در واسط Message Service اضافه کنید.
3.	در بدنه‌ی تابع مذکور - مشابه با دیگر توابع پیاده سازی شده -  از یک دستور چاپ ساده بر روی صفحه نمایش استفاده کنید.
4.	در ادامه، سعی کنید که قابلیت ارسال پیام تلگرامی را نیز به برنامه اضافه کنید؛ یعنی کاری کنید که کاربر بتواند در قالب روش سوم پیام خود را با داشتن آیدی مبدا و آیدی مقصد و متن پیام، ارسال کند.
5.	تغییراتی را که در کد فعلی برنامه می‌دهید، در جدول زیر ثبت کنید و در نهایت تعداد کل تغییرات را اعلان کنید.
    - توجه: مواردی که به عنوان تغییرات باید اعلان شود شامل این موارد هستند:
      1. ساخت کلاس جدید
      2. افزودن تابع جدید به کلاس و یا واسط (برای توابع جدید صرفا اعلام تغییر کنید)
      3. هر خطوط پیاپی‌ای که در تابع main و برای افزودن یک قابلیت جدید اضافه می‌کنید. به عنوان مثال اگر سه خط را به منظور تشخیص نوع پیام اضافه می‌کنید، آن سه خط را در قالب یک تغییر اعلام کنید (البته جزییات آن را در ستون «شرحی کوتاه از تغییر» توضیح دهید).

<table dir='rtl'>
<tbody>
<tr>
<td width="64">
<p><strong>ردیف</strong></p>
</td>
<td width="198">
<p><strong>محل اعمال تغییرات (کلاس/واسط)</strong></p>
</td>
<td width="141">
<p><strong>عنوان تغییر</strong></p>
</td>
<td width="292">
<p><strong>شرحی کوتاه از تغییر</strong></p>
</td>
</tr>
<tr>
<td width="64">
<p><strong>1</strong></p>
</td>
<td width="198">
<p>MessageService</p>
</td>
<td width="141">
<p>افزودن تابع ارسال پیام تلگرامی</p>
</td>
<td width="292">
<p>افزودن یک تابع void با عنوان sendTelegramMessage</p>
</td>
</tr>

<tr>
<td width="64">
<p><strong>2</strong></p>
</td>
<td width="198">
<p>TelegramMessageService</p>
</td>
<td width="141">
<p>اضافه کردن کلاس</p>
</td>
<td width="292">
<p>این کلاس مربوط به توابع سرویس‌دهنده به پیام‌رسانی از طریق تلگرام است</p>
</td>
</tr>

<tr>
<td width="64">
<p><strong>3</strong></p>
</td>
<td width="198">
<p>TelegramMessage </p>
</td>
<td width="141">
<p>اضافه کردن کلاس</p>
</td>
<td width="292">
<p>این کلاس مدل مربوط به پیام‌رسان تلگرام است که برای get و set کردن id مربوط به مبدا و مقصد است.</p>
</td>
</tr>

<tr>
<td width="64">
<p><strong>4</strong></p>
</td>
<td width="198">
<p>SmsMessageService </p>
</td>
<td width="141">
<p>اضافه کردن تابع sendTelegramMessage  </p>
</td>
<td width="292">
<p>تابع با بدنه‌ی خالی اضافه می‌کنیم  که override شده.</p>
</td>
</tr>

<tr>
<td width="64">
<p><strong>5</strong></p>
</td>
<td width="198">
<p>EmailMessageService </p>
</td>
<td width="141">
<p>اضافه کردن تابع sendTelegramMessage  </p>
</td>
<td width="292">
<p>تابع با بدنه‌ی خالی اضافه می‌کنیم  که override شده.</p>
</td>
</tr>

<tr>
<td width="64">
<p><strong>6</strong></p>
</td>
<td width="198">
<p>TelegramMessageService </p>
</td>
<td width="141">
<p>اضافه کردن تابع به TelegramMessageService	</p>
</td>
<td width="292">
<p>	تابع sendTelegramMessage را پیاده‌سازی میکنیم.</p>
</td>
</tr>

<tr>
<td width="64">
<p><strong>7</strong></p>
</td>
<td width="198">
<p>TelegramMessageService </p>
</td>
<td width="141">
<p>اضافه کردن تابع به TelegramMessageService	</p>
</td>
<td width="292">
<p>	تابع validateTelegramID را پیاده‌سازی میکنیم.</p>
</td>
</tr>

<tr>
<td width="64">
<p><strong>8</strong></p>
</td>
<td width="198">
<p>TelegramMessageService </p>
</td>
<td width="141">
<p>اضافه کردن توابع به TelegramMessageService	</p>
</td>
<td width="292">
<p>	توابع sendEmailMessage و sendSmsMessage را با بدنه‌ی خالی اضافه میکنیم. </p>
</td>
</tr>


<tr>
<td width="64">
<p><strong>9</strong></p>
</td>
<td width="198">
<p>Main </p>
</td>
<td width="141">
<p>اضافه کردن prompt جدید و مدیریت آن   </p>
</td>
<td width="292">
<p>  علاوه‌بر prompt یک case جدید هم به switch_case اضافه میکنیم تا محتوای آن را مشخص کنیم.</p>
</td>
</tr>

<tr>
<td width="64">
<p><strong>10</strong></p>
</td>
<td width="198">
<p>Main </p>
</td>
<td width="141">
<p>اضافه کردن instance جدید برای پیام تلگرامی   </p>
</td>
<td width="292">
<p>یک instance از کلاس TelegramMessageService در صورت اینکه message == telegramMessage</p>
</td>
</tr>


</tbody>
</table>

مجموع تعداد تغییرات: 10


### گام ۲: تحلیل و وارسی برنامه از منظر تحقق و یا عدم تحقق اصول SOLID
در خصوص این برنامه‌ای که نوشته شده بود و شما یک قابلیت به آن اضافه کردید، بر اساس اصول SOLID موارد نقض و یا محقق شدن هر کدام از آن اصول را بیان کنید. در بیان موارد تحقق و نقض، علت تحقق و یا نقض را نیز به صورت کامل توضیح دهید:

<table dir='rtl'>
<tbody>
<tr>
<td rowspan="2" width="240">
<p>اصل 1</p>
<p>Single Responsibility</p>
</td>
<td width="95">
<p><strong>موارد تحقق</strong></p>
</td>
<td width="454">
<p>  برای هر کدام از مدل ها این مورد رعایت شده، هر کدام از مدل ها تعدادی متغیر تعریف کرده و توابع getter و setter برای خود تعریف کردند که نشان می دهد که وظیفه ی پاسخ گویی  به همان متغیر های خود را به عهده دارند.</p>
</td>
</tr>
<tr>
<td>
<p><strong>موارد نقض</strong></p>
</td>
<td>
<p>برای سرویس ها این نکته رعایت نشده. چرا که اولا هر کلاسی دارد دو تا سرویس مجزا (validation و send) را انجام می دهد و لذا دو دلیل مختلف برای تغییر این فایل ها وجود دارد. در ضمن، طراحی بد کد باعث شده که حتما هر کلاسی حتی برای توابعی که خودشان پیاده سازی نمی کنند، آن تابع را خالی بگذارند. </p>
</td>
</tr>
<tr>
<td rowspan="2">
<p>اصل 2</p>
<p>Open-Close Principle (OCP)</p>
</td>
<td>
<p><strong>موارد تحقق</strong></p>
</td>
<td>
<p>  مدل ها این ویژگی را دارند، چرا که اگر قرار باشد مدل جدیدی برای extend کردن اضافه کنیم، مشابه ایمیل می توان متغیر های خودش را تعریف کرد و setter و getter های خودش را هم نوشت یا اگر مثلا در خود فایل Message مورد جدیدی اضافه کنیم، بدون نیاز به تغییر فایل ایمیل و ... می توان این کار را انجام داد. اما نکته ی جزئی تر این است که فایل Message به قصد ارسال پیام علاوه بر متن پیام، ورودی و خروجی هم دارد اما متاسفانه هر فرزندی جداگانه این ها را تکرار کرده، این یعنی اگر قرار باشد یک تغییری، مثلا تغییر در getter مربوط به ورودی بدهیم، آن وقت باید این تغییر را در تک تک فایل های ایمیل، sms، ... اعمال کرد چون که این ها به درستی در کلاس پدر گذاشته نشده بودند. </p>
</td>
</tr>
<tr>
<td>
<p><strong>موارد نقض</strong></p>
</td>
<td>
<p>برای سرویس ها این ویژگی پیاده سازی نشده چرا که اگر مثلا واسط جدیدی برای واتساپ اضافه شود، لازم است که وارد کد فایل مربوط به سایر واسط ها برویم و برای آنها، تابع متناظر با واتساپ را خالی بگذاریم و در ضمن، در فایل MessageService باید یک خط جدید متناظر تعریف آن واسط واتساپ تعریف کرد، تازه داخل واتساپ باید تمام توابع متناظر با سایرین را هم خالی گذاشت. کاملا پیچیدگی اضافه کردن کد و نیاز به تغییر دادن محتوای سایر فایل ها دیده می شود.  </p>
</td>
</tr>
<tr>
<td rowspan="2">
<p>اصل 3</p>
<p>Liskov Substitution Principle</p>
</td>
<td>
<p><strong>موارد تحقق</strong></p>
</td>
<td>
<p> برای مدل ها برقرار است، مثلا اگر شما instance از SmsMessage بگیرید، می توانید از ویژگی های پدرش (مثل content از Message) استفاده کند که این را اتفاقا در واسط ها می بینید که content ها دارند ارسال می شوند!</p>
</td>
</tr>
<tr>
<td>
<p><strong>موارد نقض</strong></p>
</td>
<td>
<p>برای واسط ها هم برقرار است چون الان فایل MessageService صرفا ظاهر کلی توابع را معرفی کرده، بعدا هر کدام از فایل های متناظر با ایمیل ... تمام توابع را می توانند پیاده سازی کنند و این تصمیم برنامه نویس بوده که تابع مربوط به خودشان را پر کنند و توابع غیر مرتبط با خودشان را خالی بگذارند.</p>
</td>
</tr>
<tr>
<td rowspan="2">
<p>اصل 4</p>
<p>Interface Segregation Principle</p>
</td>
<td>
<p><strong>موارد تحقق</strong></p>
</td>
<td>
<p> برای مدل ها برقرار است، اصولا رعایت شده، هر تابعی مربوط به متغیر های تعریف شده خود کلاس است.</p>
</td>
</tr>
<tr>
<td>
<p><strong>موارد نقض</strong></p>
</td>
<td>
<p>برای واسط ها برقرار نیست، کاملا واضح است که یک واسط درشت دانه به اسم MessageService دارد که شامل جزئیات تمام کسانی است که از آن استفاده می کنند، طوری که هر سرویس مثل ایمیل الان خودش باید این موضوع را رعایت کند که تابع مربوط به خودش را پیاده سازی کند و توابع سایرین را خالی بگذارد چون یک واسط خیلی درشت دانه ساخته شده که همه سرویس ها از ان استفاده می کنند.</p>
</td>
</tr>
<tr>
<td rowspan="2">
<p>اصل 5</p>
<p>Dependency Inversion Principle</p>
</td>
<td>
<p><strong>موارد تحقق</strong></p>
</td>
<td>
<p>برای مدل ها این نکته رعایت شده یعنی موجودیت های concrete به هم متصل نشدند، صرفا یک فایل Message هست که سایرین در صورت نیاز از آن extend کردند و برای ارتباط با هم، از واسط های سرویس ها استفاده می کنند. البته نکته ای که در ocp گفته شد، درباره این که به نظر می رسد بتوان source و target ها را به سمت پدر برد، هم اینجا برقرار است یعنی می توان آن ها را به چشم موجودیت های concrete دید که با هم ادغام شده اند چرا که رعایت dip برای رسیدن به ocp مهم است.</p>
</td>
</tr>
<tr>
<td>
<p><strong>موارد نقض</strong></p>
</td>
<td>
<p>برای واسط ها این نکته رعایت نشده چرا که موجودیت های مربوط به validate و send برای هر یک از سرویس ها، با همدیگر، ادغام و متصل شدند. با زاویه دید دیگر، الان فایل MessageService داخلش شامل جزئیات مربوط به تمام سرویس ها است و concreteness در ارتباطات مشخص است و از یک abstract خوبی استفاده نشده.</p>
</td>
</tr>
</tbody>
</table>

در خصوص هرکدام از موارد نقض هرکدام از اصول، یک راهکار را به منظور رفع آن مشکل ارایه داده و در جدول زیر ثبت نمایید:

<table dir='rtl'>
<tbody>
<tr>
<td width="168">
<p><strong>اصل مربوطه (از اصول </strong><strong>SOLID</strong><strong>)</strong></p>
</td>
<td width="246">
<p><strong>علت نقض</strong></p>
</td>
<td width="284">
<p><strong>راه حل پیشنهادی</strong></p>
</td>
</tr>
<tr>
<td width="168">
<p>SRP</p>
</td>
<td width="246">
<p> در واسط ها دو کار مجزا validate و send انجام می شود.</p>
</td>
<td width="284">
<p>برای واسط، می آییم دو تا interface جدا، یکی برای send یکی برای validate تعریف کنیم تا این شرط برقرار شود.</p>
</td>
</tr>
<tr>
<td width="168">
<p>OCP</p>
</td>
<td width="246">
<p>در مدل ها، یکی در مدل ها است که می بینیم بهتر است source و target درپدر قرار داده شوند. در واسط ها هم توابع مربوط به هر سرویس در سایرین هم هست و ترکیب شده اند.</p>
</td>
<td width="284">
<p>برای مدل ها، می آییم ورودی و خروجی را به سمت پدر خود می فرستیم چرا که در این پیاده سازی فعلی، لزومی بر جداسازی آنان دیده نشده، در صورتی که در آینده لازم باشد متغیر محلی برای یکی از کلاس ها نوشته شود، می تواند در کلاس فرزند آن را تعریف کند اما در حال حاضر، می توان source و target را به سمت پدر برد. همچنین، برای واسط ها، این راه حل را ارائه می کنیم که واسط پدر، یک تابع کلی داشته باشد که هر یک از فرزندان بخواهد همان تابع پدر خود را پیاده سازی کند. (به جای اینکه پدر تمام توابع فرزندان خود را داشته باشد بعدا هر فرزند توابع سایرین داخل کلاس خودش را خالی بگذارد)</p>
</td>
</tr>
<tr>
<td width="168">
<p>ISP</p>
</td>
<td width="246">
<p>یک واسط درشت دانه داریم که این شکانده نشده است به چندین تا واسط ریزدانه.</p>
</td>
<td width="284">
<p>اگر هر دو نکته ی گفته شده در سطر اول و دوم این جدول (یعنی هم جداسازی interface ها به دو بخش validate و send و همچنین، تنها قرار دادن یک تابع در پدر) را انجام دهیم، خود به خود، این شرط هم برقرار می شود.</p>
</td>
</tr>
<tr>
<td width="168">
<p>DIP</p>
</td>
<td width="246">
<p>چون موجودیت های concrete از جمله send و validation و همچنین توابع مربوط به هر یک از کلاس ها، با همدیگر ادغام شده اند. همچنین، برای مدل ها می توان source و target را به سمت پدر برد.</p>
</td>
<td width="284">
<p> اگر هر دو نکته ی گفته شده در سطر اول و دوم این جدول (یعنی هم جداسازی interface ها به دو بخش validate و send و همچنین، تنها قرار دادن یک تابع در پدر) را انجام دهیم، خود به خود، این شرط هم برقرار می شود. برای مدل هم آن مورد سطر دوم را انجام می دهیم.</p>
</td>
</tr>
</tbody>
</table>

### گام ۴: بررسی مجدد تغییرات مورد نیاز
فرض کنید که گام 1 را برای کد اصلاح شده (پس از انجام گام‌های ۲ و ۳) اجرا کرده‌اید.
1. در این صورت از انجام کدام یک از تغییرات ثبت شده در جدول گام ۱ معاف خواهید شد؟
2. تعداد تغییرات مورد نیاز، چند تغییر خواهد شد؟

### گام ۵: جمع بندی
در این بخش، بیان کنید که از این گام چه نتیجه‌ای گرفته‌اید؟ و به نظر شما به کارگیری صحیح اصول SOLID در گام‌های ۳ و ۴ چه مزایایی را نسبت به حالتی دارد که این اصول رعایت نشده‌بود؟